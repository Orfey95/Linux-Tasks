1) Найти все системные группы и получить только их уникальные имена и id. Сохранить в файл. 
```
vagrant@task1:~$ cat /etc/group | egrep "x:(0?[1-9]|[1-9][0-9]):" > out.txt
vagrant@task1:~$ cat out.txt
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:syslog,ubuntu
tty:x:5:
disk:x:6:
lp:x:7:
mail:x:8:
news:x:9:
uucp:x:10:
man:x:12:
proxy:x:13:
kmem:x:15:
dialout:x:20:ubuntu
fax:x:21:
voice:x:22:
cdrom:x:24:ubuntu
floppy:x:25:ubuntu
tape:x:26:
sudo:x:27:ubuntu
audio:x:29:ubuntu
dip:x:30:ubuntu
www-data:x:33:
backup:x:34:
operator:x:37:
list:x:38:
irc:x:39:
src:x:40:
gnats:x:41:
shadow:x:42:
utmp:x:43:
video:x:44:ubuntu
sasl:x:45:
plugdev:x:46:ubuntu
staff:x:50:
games:x:60:
```
2) Найти все файлы и директории, который имеют права для доступа соответствующих user и group.
```
vagrant@task1:~$ find -uid 1000 -gid 1000
.
./.ssh
./.ssh/authorized_keys
./.bash_logout
./.gnupg
./.gnupg/private-keys-v1.d
./.cache
./.cache/motd.legal-displayed
./.profile
./scripts
./scripts/script2.sh
./scripts/sub_scripts
./scripts/sub_scripts/script3.sh
./scripts/script1.sh
./.bashrc
```
3) Найти все скрипты в указанной директории и ее поддиректориях.
<br>**Environment:**
```
vagrant@task1:~$ tree
.
└── scripts
    ├── script1.sh
    ├── script2.sh
    └── sub_scripts
        └── script3.sh

2 directories, 3 files
```
```
vagrant@task1:~$ find . -name "*.sh"
./scripts/script2.sh
./scripts/sub_scripts/script3.sh
./scripts/script1.sh
```
4) Выполнить поиск файлов скриптов из под определенного пользователя.
```
vagrant@task1:~$ sudo find / -user vagrant -name "*.sh"
/home/vagrant/scripts/script2.sh
/home/vagrant/scripts/sub_scripts/script3.sh
/home/vagrant/scripts/script1.sh
```
5) Выполнить рекурсивный поиск слов или фразы для определенного типа файлов. 
6) Найти дубликаты файлов в заданных каталогах. Вначале сравнивать по размеру, затем по варианту (выбрать хешь функцию: CRC32, MD5, SHA-1, sha224sum). Результат должен быть отсортирован по имени файла. 
7) Найти по имени файла и его пути все символьные ссылки на него. 
<br>**Environment:**
```
vagrant@task1:~$ touch file
vagrant@task1:~$ ln -s file file_soft_link
vagrant@task1:~$ ls -li
total 2
 60377 -rw-rw-r-- 2 vagrant vagrant    0 Feb 12 15:56 file
 60380 lrwxrwxrwx 1 vagrant vagrant    4 Feb 12 15:57 file_sl -> file

```
```
vagrant@task1:~$ find -lname file
./file_soft_link
```
8) Найти по имени файла и его пути все жесткие ссылки на него. 
<br>**Environment:**
```
vagrant@task1:~$ touch file
vagrant@task1:~$ ln file file_hard_link
vagrant@task1:~$ ls -li
total 2
 60377 -rw-rw-r-- 2 vagrant vagrant    0 Feb 12 15:56 file
 60377 -rw-rw-r-- 2 vagrant vagrant    0 Feb 12 15:56 file_hl

```
```
vagrant@task1:~$ find -samefile file
./file
./file_hard_link
```
9) Имеется только inode файла найти все его имена. 
<br>**Environment:**
```
vagrant@task1:~$ ls -li
total 2
 60377 -rw-rw-r-- 2 vagrant vagrant    0 Feb 12 15:56 file
 60377 -rw-rw-r-- 2 vagrant vagrant    0 Feb 12 15:56 file_hl
```
```
vagrant@task1:~$ find -inum 60377
./file
./file_hl
```
10) Имеется только inode файла найти все его имена. Учтите, что может быть примонтированно несколько разделов.
11) Корректно удалить файл с учетом возможности существования символьных или жестких ссылок.
12) Рекурсивно изменить права доступа к файлам (задана маска файла) в заданной директории. 
13) Сравнить рекурсивно две директории и отобразить только отличающиеся файлы. * (вывести до 2 строки и после 3 строки относительно строки в которой найдено отличие). 
14) Получить MAC-адреса сетевых интерфейсов.
```
vagrant@task1:~$ ifconfig | egrep "ether " | cut -b 15-31
02:57:a3:c3:eb:b7
08:00:27:99:fc:18
```
15) Вывести список пользователей, авторизованных в системе на текущий момент. 
```
vagrant@task1:~$ who
vagrant  pts/0        2020-02-12 14:39 (10.0.2.2)
```
16) Вывести список активных сетевых соединений в виде таблицы: тип состояния соединения и их количество. 
17) Переназначить существующую символьную ссылку.
18) Имется список фалов с относительным путем и путем к каталогу в котором должна храниться символьная ссылка на файл. Создать символьные ссылки на эти файлы. 
19) Скопировать директорию с учетом, что в ней существуют как прямые так относительные символьные ссылки на файлы и директории. Предполагается, что копирование выполняется for backup on a removable storage. (сделать в двух вариантах, без rsync и с rsync). 
20) Скопировать директорию с учетом, что в ней существуют прямые символьные относительные символьные ссылки. 
21) В директории проекта преобразовать все относительные ссылки в прямые.
22) В директории проекта преобразовать все прямые ссылки в относительные для директории проекта.
23) В указанной директории найти все сломанные ссылки и удалить их. 
24) Распаковать из архива tar, gz, bz2, lz, lzma, xz, Z определенный каталог в указанное место. 
25) Рекурсивно скопировать структуру каталогов из указанной директории. (без файлов). 
26) Вывести список всех пользователей системы (только имена) по алфавиту.
27) Вывести список всех системных пользователей системы отсортированных по id, в формате: login id. 
28) Вывести список всех пользователей системы (только имена) отсортированные по id.
29) Вывести всех пользователей которые не имеют право авторизовываться или не имеют право авторизовываться в системе. (две команды). 
30) Вывести всех пользователей которые (имеют/не имеют) терминала (bash, sh, zsh and etc.) (две команды).
31) Со страницы из интернета закачать все ссылки, которые на странице. Закачивать параллельно. Использовать curl и wget. Дать рекомендации по использованию. 
32) Остановить процессы, которые работают больше 5 дней. Команду ps не использовать. 
33) Имется дериктория, в которой, существуют папки и файлы (*.txt & *.jpeg). Файлы *.txt и *.jpeg однозначно связаны между собой по префиксу имени. Файлы могут находиться в различном месте данной директории. Нужно удалить все *.jpeg для которых не существует файла *.txt.
34) Find your IP address using the command line.
35) Получить все ip-адресса из текстового файла.
36) Найти все активные хосты в: - заданной сети,  - списке IP (hosts-server.txt) используя/не используя nMAP.
37) Используя результат таска 36. Получить ip поднятых хостов. 
38) Получить все поддоиены из SSL сертификата.

